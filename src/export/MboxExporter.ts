import { readdir, stat } from "fs/promises";
import { join } from "path";
import { format } from "date-fns";
import { createGzip } from "zlib";
import { pipeline } from "stream/promises";
import { createReadStream, createWriteStream } from "fs";
import { logger } from "../utils/logger.js";
import type {
  EmailMessage,
  ExportOptions,
  MboxMessage,
  EmailAddress,
} from "../types/index.js";
import ora from "ora";

export class MboxExporter {
  /**
   * Export downloaded emails to MBOX format
   */
  async exportToMbox(options: ExportOptions): Promise<void> {
    const spinner = ora("Initializing MBOX export...").start();

    try {
      logger.header("MBOX Export");

      // Get all email files
      spinner.text = "Scanning email files...";
      const emailFiles = await this.getEmailFiles(options.inputPath);

      if (emailFiles.length === 0) {
        spinner.succeed("No email files found to export");
        logger.footer();
        return;
      }

      logger.info(`Found ${emailFiles.length} email files to export`);

      // Create MBOX file
      spinner.text = "Creating MBOX file...";
      const outputPath = options.compress
        ? options.outputPath.replace(/\.mbox$/, ".mbox.gz")
        : options.outputPath;

      await this.createMboxFile(emailFiles, outputPath, options.compress);

      spinner.succeed(
        `Successfully exported ${emailFiles.length} emails to ${outputPath}`
      );
      logger.footer();
    } catch (error) {
      spinner.fail("MBOX export failed");
      throw error;
    }
  }

  /**
   * Get all email JSON files from the input directory
   */
  private async getEmailFiles(inputPath: string): Promise<string[]> {
    try {
      const files = await readdir(inputPath);
      const emailFiles: string[] = [];

      for (const file of files) {
        if (file.endsWith(".json")) {
          const filePath = join(inputPath, file);
          const stats = await stat(filePath);

          if (stats.isFile()) {
            emailFiles.push(filePath);
          }
        }
      }

      // Sort files by name (which includes date) for chronological order
      return emailFiles.sort();
    } catch (error) {
      throw new Error(`Failed to read email files: ${error}`);
    }
  }

  /**
   * Create the MBOX file from email files
   */
  private async createMboxFile(
    emailFiles: string[],
    outputPath: string,
    compress: boolean
  ): Promise<void> {
    const writeStream = createWriteStream(outputPath);
    let finalStream = writeStream;

    if (compress) {
      const gzipStream = createGzip();
      gzipStream.pipe(writeStream);
      finalStream = gzipStream as any;
    }

    try {
      // Write MBOX header
      finalStream.write("# This is a generated MBOX file\n");
      finalStream.write("# Generated by Export Mail CLI\n");
      finalStream.write(`# Generated on: ${new Date().toISOString()}\n\n`);

      let processedCount = 0;

      for (const emailFile of emailFiles) {
        try {
          processedCount++;
          logger.step(
            processedCount,
            emailFiles.length,
            `Processing email ${processedCount}/${emailFiles.length}`
          );

          // Read and parse email
          const emailData = (await Bun.file(emailFile).json()) as EmailMessage;

          // Convert to MBOX format
          const mboxMessage = this.convertEmailToMbox(emailData);
          const mboxContent = this.formatMboxMessage(mboxMessage);

          // Write to MBOX file
          finalStream.write(mboxContent);
        } catch (error) {
          logger.warn(`Failed to process email file ${emailFile}:`, error);
        }
      }

      // Close the stream properly
      if (compress) {
        finalStream.end();
        await new Promise<void>((resolve, reject) => {
          writeStream.on("finish", () => resolve());
          writeStream.on("error", reject);
        });
      } else {
        finalStream.end();
      }

      logger.info(`Successfully exported ${processedCount} emails`);
    } catch (error) {
      throw new Error(`Failed to create MBOX file: ${error}`);
    }
  }

  /**
   * Convert EmailMessage to MboxMessage format
   */
  private convertEmailToMbox(email: EmailMessage): MboxMessage {
    const fromAddress = this.formatEmailAddress(email.from);
    const date = this.formatMboxDate(email.receivedDateTime);
    const messageId =
      email.internetMessageId || `<${email.id}@export-mail-cli>`;

    // Build headers
    const headers: Record<string, string> = {
      "Message-ID": messageId,
      Date: date,
      From: fromAddress,
      Subject: email.subject || "(No Subject)",
      To: email.toRecipients
        .map((addr) => this.formatEmailAddress(addr))
        .join(", "),
      "Content-Type":
        email.body.contentType === "html"
          ? "text/html; charset=UTF-8"
          : "text/plain; charset=UTF-8",
    };

    // Add CC if present
    if (email.ccRecipients && email.ccRecipients.length > 0) {
      headers["Cc"] = email.ccRecipients
        .map((addr) => this.formatEmailAddress(addr))
        .join(", ");
    }

    // Add BCC if present
    if (email.bccRecipients && email.bccRecipients.length > 0) {
      headers["Bcc"] = email.bccRecipients
        .map((addr) => this.formatEmailAddress(addr))
        .join(", ");
    }

    // Add Reply-To if present
    if (email.replyTo && email.replyTo.length > 0) {
      headers["Reply-To"] = email.replyTo
        .map((addr) => this.formatEmailAddress(addr))
        .join(", ");
    }

    // Add importance
    if (email.importance && email.importance !== "normal") {
      headers["Importance"] = email.importance;
    }

    // Add conversation ID
    if (email.conversationId) {
      headers["Thread-Index"] = email.conversationId;
    }

    return {
      from: fromAddress,
      date: date,
      subject: email.subject || "(No Subject)",
      messageId: messageId,
      headers: headers,
      body: this.processEmailBody(email.body.content, email.body.contentType),
    };
  }

  /**
   * Format email address for MBOX
   */
  private formatEmailAddress(emailAddr: EmailAddress): string {
    if (!emailAddr.name || emailAddr.name === emailAddr.address) {
      return emailAddr.address;
    }

    // Escape quotes in name
    const escapedName = emailAddr.name.replace(/"/g, '\\"');
    return `"${escapedName}" <${emailAddr.address}>`;
  }

  /**
   * Format date for MBOX (RFC 2822 format)
   */
  private formatMboxDate(dateString: string): string {
    try {
      const date = new Date(dateString);
      return date.toUTCString();
    } catch (error) {
      return new Date().toUTCString();
    }
  }

  /**
   * Process email body content
   */
  private processEmailBody(content: string, contentType: string): string {
    if (!content) {
      return "";
    }

    // Escape any lines that start with "From " to prevent MBOX parsing issues
    const processedContent = content
      .split("\n")
      .map((line) => (line.startsWith("From ") ? `>${line}` : line))
      .join("\n");

    return processedContent;
  }

  /**
   * Format complete MBOX message
   */
  private formatMboxMessage(mboxMessage: MboxMessage): string {
    const lines: string[] = [];

    // MBOX separator line (From line)
    const fromLine = `From ${this.extractEmailFromAddress(
      mboxMessage.from
    )} ${this.formatMboxFromDate(mboxMessage.date)}`;
    lines.push(fromLine);

    // Headers
    for (const [key, value] of Object.entries(mboxMessage.headers)) {
      if (value) {
        lines.push(`${key}: ${value}`);
      }
    }

    // Empty line between headers and body
    lines.push("");

    // Body
    lines.push(mboxMessage.body);

    // Double newline to separate messages
    lines.push("");
    lines.push("");

    return lines.join("\n");
  }

  /**
   * Extract email address from formatted string
   */
  private extractEmailFromAddress(formattedAddress: string): string {
    const match = formattedAddress.match(/<(.+)>/);
    return match?.[1] || formattedAddress;
  }

  /**
   * Format date for "From " line (ctime format)
   */
  private formatMboxFromDate(rfc2822Date: string): string {
    try {
      const date = new Date(rfc2822Date);
      return date.toString(); // ctime format
    } catch (error) {
      return new Date().toString();
    }
  }

  /**
   * Validate MBOX output
   */
  private async validateMboxFile(filePath: string): Promise<boolean> {
    try {
      const content = await Bun.file(filePath).text();

      // Basic validation: check for proper From lines
      const fromLines = content.match(/^From .+$/gm);

      if (!fromLines || fromLines.length === 0) {
        logger.warn('No proper "From " lines found in MBOX file');
        return false;
      }

      logger.info(`MBOX validation passed: found ${fromLines.length} messages`);
      return true;
    } catch (error) {
      logger.warn("Failed to validate MBOX file:", error);
      return false;
    }
  }
}
